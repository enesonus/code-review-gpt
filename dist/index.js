#!/usr/bin/env node
var fo=Object.create;var{getPrototypeOf:uo,defineProperty:C,getOwnPropertyNames:so}=Object;var po=Object.prototype.hasOwnProperty;var b=(r,e,o)=>{o=r!=null?fo(uo(r)):{};let i=e||!r||!r.__esModule?C(o,"default",{value:r,enumerable:!0}):o;for(let n of so(r))if(!po.call(i,n))C(i,n,{get:()=>r[n],enumerable:!0});return i};var F=(r,e)=>{for(var o in e)C(r,o,{get:e[o],enumerable:!0,configurable:!0,set:(i)=>e[o]=()=>i})};var p=(r,e)=>()=>(r&&(e=r(r=0)),e);var Ar,c;var d=p(()=>{Ar=require("tslog"),c=new Ar.Logger({prettyLogTemplate:"{{logLevelName}}\t"})});var ar=()=>{let r=process.env.OPENAI_API_KEY,e=process.env.AZURE_OPENAI_API_KEY;if(!r&&!e)c.error("Neither OPENAI_API_KEY nor AZURE_OPENAI_API_KEY is set");return r??e??""},_r=()=>{if(!process.env.GITHUB_TOKEN)c.error("GITHUB_TOKEN is not set");return process.env.GITHUB_TOKEN??""},$=()=>{let r=["GITHUB_SHA","BASE_SHA","GITHUB_TOKEN"],e=[];for(let o of r)if(!process.env[o])e.push(o);if(e.length>0)throw c.error(`Missing environment variables: ${e.join(", ")}`),new Error("One or more GitHub environment variables are not set");return{githubSha:process.env.GITHUB_SHA??"",baseSha:process.env.BASE_SHA??"",githubToken:process.env.GITHUB_TOKEN??""}},A=()=>{let r=["CI_MERGE_REQUEST_DIFF_BASE_SHA","CI_PROJECT_ID","CI_MERGE_REQUEST_IID","CI_COMMIT_SHA","GITLAB_TOKEN","GITLAB_HOST"].filter((e)=>!process.env[e]);if(r.length>0)throw c.error(`Missing environment variables: ${r.join(", ")}`),new Error("One or more GitLab environment variables are not set. Did you set up your Gitlab access token? Refer to the README (Gitlab CI section) on how to set it up.");return{mergeRequestBaseSha:process.env.CI_MERGE_REQUEST_DIFF_BASE_SHA??"",gitlabSha:process.env.CI_COMMIT_SHA??"",gitlabToken:process.env.GITLAB_TOKEN??"",projectId:process.env.CI_PROJECT_ID??"",mergeRequestIIdString:process.env.CI_MERGE_REQUEST_IID??"",gitlabHost:process.env.GITLAB_HOST??"https://gitlab.com"}},T=()=>{let r=["SYSTEM_PULLREQUEST_SOURCECOMMITID","BASE_SHA","API_TOKEN"],e=[];for(let o of r)if(!process.env[o])e.push(o);if(e.length>0)throw c.error(`Missing environment variables: ${e.join(", ")}`),new Error("One or more Azure DevOps environment variables are not set");return{azdevSha:process.env.SYSTEM_PULLREQUEST_SOURCECOMMITID??"",baseSha:process.env.BASE_SHA??"",azdevToken:process.env.API_TOKEN??""}};var a=p(()=>{d()});var G=()=>{};var Ir,H=async(r)=>{let e=await Ir.glob(r,{onlyFiles:!0});if(e.length===0)throw new Error(`No template file found for pattern: ${r}`);return e[0]};var yr=p(()=>{Ir=require("tinyglobby")});var Gr={};F(Gr,{configure:()=>go});var N,_,U,Fr,go=async(r)=>{if(r.setupTarget==="github")await bo();if(r.setupTarget==="gitlab")await ho();if(r.setupTarget==="azdev")await lo()},$r=async()=>{return await Fr.password({message:"Please input your OpenAI API key:"})},bo=async()=>{let r=await H("**/templates/github-pr.yml"),e=U.default.join(process.cwd(),".github","workflows");_.default.mkdirSync(e,{recursive:!0});let o=U.default.join(e,"code-review-gpt.yml");_.default.writeFileSync(o,_.default.readFileSync(r,"utf8"),"utf8"),c.info(`Created GitHub Actions workflow at: ${o}`);let i=await $r();if(!i){c.error("No API key provided. Please manually add the OPENAI_API_KEY secret to your GitHub repository.");return}try{N.execSync("gh auth status || gh auth login",{stdio:"inherit"}),N.execSync(`gh secret set OPENAI_API_KEY --body=${String(i)}`),c.info("Successfully added the OPENAI_API_KEY secret to your GitHub repository.")}catch(n){c.error("It seems that the GitHub CLI is not installed or there was an error during authentication. Don't forget to add the OPENAI_API_KEY to the repo settings/Environment/Actions/Repository Secrets manually.")}},ho=async()=>{let r=await H("**/templates/gitlab-pr.yml"),e=process.cwd(),o=U.default.join(e,".gitlab-ci.yml");_.default.writeFileSync(o,_.default.readFileSync(r,"utf8"),"utf8"),c.info(`Created GitLab CI at: ${o}`);let i=await $r();if(!i){c.error("No API key provided. Please manually add the OPENAI_API_KEY secret to your GitLab CI/CD environment variables for your repository.");return}try{N.execSync("glab auth login",{stdio:"inherit"}),N.execSync(`glab variable set OPENAI_API_KEY ${String(i)}`),c.info(`Successfully added the OPENAI_API_KEY secret to your GitLab repository.
 Please make sure you have set up your Gitlab access token before using this tool. Refer to the README (Gitlab CI section) for information on how to do this.`)}catch(n){c.error("It seems that the GitLab CLI is not installed or there was an error during authentication. Don't forget to add the OPENAI_API_KEY and the GITLAB_TOKEN to the repo's CI/CD Variables manually. Refer to the README (Gitlab CI section)for information on how to set up your access token.")}},lo=async()=>{let r=await H("**/templates/azdev-pr.yml"),e=process.cwd(),o=U.default.join(e,"code-review-gpt.yaml");_.default.writeFileSync(o,_.default.readFileSync(r,"utf8"),"utf8"),c.info(`Created Azure DevOps Pipeline at: ${o}`),c.info("Please manually add the OPENAI_API_KEY and API_TOKEN secrets as encrypted variables in the UI.")};var Rr=p(()=>{N=require("child_process"),_=b(require("fs")),U=b(require("path")),Fr=require("@inquirer/prompts");G();d();yr()});var K,vo=()=>{let r=["SYSTEM_TEAMFOUNDATIONCOLLECTIONURI","API_TOKEN","SYSTEM_PULLREQUEST_PULLREQUESTID","BUILD_REPOSITORY_ID","SYSTEM_TEAMPROJECTID"],e=[];for(let o of r)if(!process.env[o])e.push(o);if(e.length>0)throw c.error(`Missing environment variables: ${e.join(", ")}`),new Error("One or more Azure DevOps environment variables are not set");return{serverUrl:process.env.SYSTEM_TEAMFOUNDATIONCOLLECTIONURI??"",azdevToken:process.env.API_TOKEN??"",pullRequestId:process.env.SYSTEM_PULLREQUEST_PULLREQUESTID??"",project:process.env.SYSTEM_TEAMPROJECTID??"",repositoryId:process.env.BUILD_REPOSITORY_ID??""}},kr=async(r,e)=>{try{let{serverUrl:o,azdevToken:i,pullRequestId:n,repositoryId:t,project:f}=vo(),u=Number(n),w=K.getPersonalAccessTokenHandler(i),g=await new K.WebApi(o,w).getGitApi(),l={comments:[{content:`${r}

---

${e}`}]};await g.createThread(l,t,u,f)}catch(o){throw c.error(`Failed to comment on PR: ${JSON.stringify(o)}`),o}};var Nr=p(()=>{K=b(require("azure-devops-node-api"));d()});var rr=(r)=>{return r.map((e)=>`
${e.reasoning}

${e.suggestedChanges?`Suggested changes:
\`\`\`suggestion
${e.suggestedChanges}
\`\`\`
`:""}

<details>
<summary>View Original Code</summary>

\`\`\`code
${e.targetCodeBlock}
\`\`\`

</details>
`).join(`
`)},mo=(r)=>`
**Risk Level ${r.riskScore} - ${r.fileName}**

${rr(r.review)}
`,Ur=(r)=>`
${r.map(mo).join(`
---
`)}
`;var S,Eo=(r,e)=>{let o=r.lastIndexOf(e);if(o!==-1)return r.slice(o+e.length+1);return r},er=()=>{let{githubToken:r}=$();if(!r)throw new Error("GITHUB_TOKEN is not set");return r},Or=()=>{let r=er(),{payload:e,issue:o}=S.context;if(!e.pull_request){c.warn("Not a pull request. Skipping commenting on PR...");return}let i=S.getOctokit(r),{owner:n,repo:t,number:f}=o;return{octokit:i,owner:n,repo:t,pull_number:f}},Tr=async(r,e)=>{try{let o=`${rr(e.feedback.review)}

---

${e.signOff}`,{data:i}=await r.rest.pulls.listReviewComments({owner:e.owner,repo:e.repo,pull_number:e.pull_number}),n=Eo(e.feedback.fileName,e.repo),t=i.find((f)=>f.path===n&&f.body.includes(e.signOff));if(t)await r.rest.pulls.updateReviewComment({owner:e.owner,repo:e.repo,comment_id:t.id,body:o});else await r.rest.pulls.createReviewComment({owner:e.owner,repo:e.repo,pull_number:e.pull_number,body:o,commit_id:e.commit_id,path:n,subject_type:"FILE"})}catch(o){c.error(`Failed to comment on PR for feedback: ${e.feedback.review}. Error: ${JSON.stringify(o)}`)}};var or=p(()=>{S=require("@actions/github");a();d()});var P,Y=async(r,e)=>{try{let o=er(),{payload:i,issue:n}=P.context;if(!i.pull_request){c.warn("Not a pull request. Skipping commenting on PR...");return}let t=P.getOctokit(o),{owner:f,repo:u,number:w}=n,{data:s}=await t.rest.issues.listComments({owner:f,repo:u,issue_number:w}),g=s.find((m)=>m.body?.includes(e)),l=`${r}

---

${e}`;if(g)await t.rest.issues.updateComment({owner:f,repo:u,comment_id:g.id,body:l});else await t.rest.issues.createComment({owner:f,repo:u,issue_number:w,body:l})}catch(o){throw c.error(`Failed to comment on PR: ${JSON.stringify(o)}`),o}};var ir=p(()=>{P=require("@actions/github");d();or()});var Hr=async(r,e)=>{let o=Or();if(o){let{octokit:i,owner:n,repo:t,pull_number:f}=o,w=(await i.rest.pulls.get({owner:n,repo:t,pull_number:f})).data.head.sha;for(let s of r)await Tr(i,{feedback:s,signOff:e,owner:n,repo:t,pull_number:f,commit_id:w})}};var Mr=p(()=>{or()});var Kr,B=async(r,e)=>{try{let{gitlabToken:o,projectId:i,mergeRequestIIdString:n,gitlabHost:t}=A(),f=Number.parseInt(n,10),u=new Kr.Gitlab({token:o,host:t}),s=(await u.MergeRequestNotes.all(i,f)).find((l)=>l.body.includes(e)),g=`${r}

---

${e}`;if(s)await u.MergeRequestNotes.edit(i,f,s.id,{body:g});else await u.MergeRequestNotes.create(i,f,g)}catch(o){throw c.error(`Failed to comment on PR: ${JSON.stringify(o)}`),o}};var nr=p(()=>{Kr=require("@gitbeaker/rest");a();d()});var Sr,Pr=async(r,e)=>{try{let{mergeRequestBaseSha:o,gitlabToken:i,projectId:n,gitlabSha:t,mergeRequestIIdString:f,gitlabHost:u}=A();console.log(`mergeRequestBaseSha: ${o}, gitlabToken: ${i}, projectId: ${n}, gitlabSha: ${t}, mergeRequestIIdString: ${f}, gitlabHost: ${u}`),process.stdout.write(`mergeRequestBaseSha: ${o}, gitlabToken: ${i}, projectId: ${n}, gitlabSha: ${t}, mergeRequestIIdString: ${f}, gitlabHost: ${u}
`);let s=new Sr.Gitlab({token:i,host:u}).Commits.show(n,t);console.log(`test: ${JSON.stringify(s)}`),process.stdout.write(`test: ${JSON.stringify(s)}
`)}catch(o){throw c.error(`Failed to comment on PR: ${JSON.stringify(o)}`),o}};var Yr=p(()=>{Sr=require("@gitbeaker/rest");a();d()});var R="#### Powered by [Code Review GPT](https://github.com/mattzcarey/code-review-gpt)",Br,tr,V,D,Vr=5;var y=p(()=>{Br=[{model:"o3-mini",maxPromptLength:300000},{model:"o1",maxPromptLength:300000},{model:"gpt-4o-mini",maxPromptLength:300000},{model:"gpt-4o",maxPromptLength:300000},{model:"gpt-4-turbo",maxPromptLength:300000},{model:"gpt-4-turbo-preview",maxPromptLength:300000},{model:"gpt-4",maxPromptLength:21000},{model:"gpt-4-32k",maxPromptLength:90000},{model:"gpt-3.5-turbo",maxPromptLength:9000},{model:"gpt-3.5-turbo-16k",maxPromptLength:45000}],tr={".js":"JavaScript",".ts":"TypeScript",".py":"Python",".sh":"Shell",".go":"Go",".rs":"Rust",".tsx":"TypeScript",".jsx":"JavaScript",".dart":"Dart",".php":"PHP",".cpp":"C++",".h":"C++",".c":"C",".cxx":"C++",".hpp":"C++",".hxx":"C++",".cs":"C#",".rb":"Ruby",".kt":"Kotlin",".kts":"Kotlin",".java":"Java",".vue":"Vue",".tf":"Terraform",".hcl":"Terraform",".swift":"Swift"},V=new Set(Object.keys(tr)),D=new Set(["types"])});var Dr=65536,z=(r)=>{let e=Br.find((o)=>o.model===r)?.maxPromptLength;if(!e)return c.warn(`Model ${r} not found in predefined list. Using default max prompt length (${Dr} chars).`),Dr;return e};var cr=p(()=>{y();d()});class O{model;constructor(r){switch(r.provider){case"openai":this.model=new j.ChatOpenAI({modelName:r.modelName,apiKey:r.apiKey,...r.organization&&{organization:r.organization},temperature:r.modelName.startsWith("o")?void 0:r.temperature});break;case"azureai":this.model=new j.AzureChatOpenAI({temperature:r.temperature});break;case"bedrock":throw new Error("Bedrock provider not implemented");default:throw new Error("Provider not supported")}}async callModel(r){return(await this.model.invoke(r)).content[0]}async callStructuredModel(r,e){let i=await this.model.withStructuredOutput(e,{method:"jsonSchema",strict:!0,includeRaw:!0}).invoke(r);if(c.debug("LLm response",i),i.parsed)return i.parsed;return Ao(i.raw.content[0])}}var j,Ao=(r)=>{c.debug("Unparsed JSON",r);let e=r.replace(/\\/g,"\\\\").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\t/g,"\\t").replace(/```/g,"\\`\\`\\`").replace(/`/g,"\\`").replace(/"/g,"\\\"").replace(/\f/g,"\\f").replace(/\b/g,"\\b").replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029");return c.debug("Escaped JSON",e),JSON.parse(e)};var fr=p(()=>{j=require("@langchain/openai");d()});var E,ao,zr;var jr=p(()=>{E=require("zod"),ao=E.z.array(E.z.object({targetCodeBlock:E.z.string().describe("The exact code block that the feedback is about verbatim. Do not include any other text or comments in the code block. Do not include ``` or any other formatting."),suggestedChanges:E.z.string().describe("The full code block including any suggested changes if it makes sense to have them. Do not include any other text or comments in the code block. Do not include ``` or any other formatting. Do not include any + or - to indicate the changes.").optional(),reasoning:E.z.string().describe("The review of the code block and the reasoning for the suggested changes (if any). Justify the changes you are making to the code block as a code reviewer would. If there are no suggested changes, just write a review of the code block.")})),zr=E.z.object({fileName:E.z.string().describe("The name of the file that the code changes are in"),riskScore:E.z.number().describe("A risk score from 1 to 5, where 1 is the lowest risk to the code base if the code is merged and 5 is the highest risk which would likely break something or be unsafe"),review:ao,confidence:E.z.number().describe("A confidence score from 1 to 5 about how confident you are in the risk score, where 1 is the lowest confidence and 5 is the highest confidence. Low confidence scores are for when you are not confident about the library being used or the code being safe. High confidence scores are for objective bad practise.")})});class Jr{items;constructor(r=[]){this.items=r}enqueue(r,e){let o={priority:e,item:r};this.items.push(o),this.items.sort((i,n)=>i.priority-n.priority)}dequeue(){return this.items.shift()?.item}size(){return this.items.length}peek(){return this.items[0]}getItems(){return this.items.map((r)=>r.item)}}var Zr;var Wr=p(()=>{Zr=Jr});var _o=async(r)=>{try{return await r}catch(e){throw c.error("Error in processing prompt",e),e}},Io=(r)=>{let e=new Zr,o=r.filter((i)=>i.riskScore>1&&i.confidence>3);for(let i of o)e.enqueue(i,i.riskScore*i.confidence);return e.getItems()},yo=(r)=>{return r.reduce((e,o)=>{if(o.status==="fulfilled")return e.concat(o.value);return e},[])},qr=async(r,e)=>{let o=e.map((t)=>r.callStructuredModel(t,zr)),i=await Promise.allSettled(o.map(_o)),n=yo(i);return Io(n)};var Qr=p(()=>{d();jr();Wr()});var J=async(r,e,o,i,n)=>{c.info("Asking the experts...");let t=new O({modelName:e,temperature:0,apiKey:o,organization:i,provider:n}),f=await qr(t,r);if(f.length===0)return{markdownReport:"No issues found in PR \uD83C\uDF89",feedbacks:[]};return{markdownReport:Ur(f),feedbacks:f}};var ur=p(()=>{fr();d();Qr()});var Xr,xr=(r)=>{let e=Xr.extname(r);return tr[e]||"Unknown Language"};var Lr=p(()=>{Xr=require("path");y()});var sr=`You are an expert {ProgrammingLanguage} developer, your task is to review a set of pull requests.
You are given a list of filenames and their partial contents, but note that you might not have the full context of the code.

Only review lines of code which have been changed (added or removed) in the pull request. The code looks similar to the output of a git diff command. Lines which have been removed are prefixed with a minus (-) and lines which have been added are prefixed with a plus (+). Other lines are added to provide context but should be ignored in the review.

Do not praise or complement anything. Only focus on the negative aspects of the code.

Begin your review by evaluating the changed code using a risk score similar to a LOGAF score but measured from 1 to 5, where 1 is the lowest risk to the code base if the code is merged and 5 is the highest risk which would likely break something or be unsafe.

In your feedback, focus on highlighting potential bugs, improving readability if it is a problem, making code cleaner, and maximising the performance of the programming language. Flag any API keys or secrets present in the code in plain text immediately as highest risk. Rate the changes based on SOLID principles if applicable.

Do not comment on breaking functions down into smaller, more manageable functions unless it is a huge problem. Also be aware that there will be libraries and techniques used which you are not familiar with, so do not comment on those unless you are confident that there is a problem.

Use markdown formatting for the feedback details. Also do not include the filename or risk level in the feedback details.

Ensure the feedback details are brief, concise, accurate, and in {ReviewLanguage}. If there are multiple similar issues, only comment on the most critical.

Include brief example code snippets in the feedback details for your suggested changes when you're confident your suggestions are improvements. Use the same programming language as the file under review.
If there are multiple improvements you suggest in the feedback details, use an ordered list to indicate the priority of the changes.

Respond in valid json making sure that all special characters are escaped properly:
- Code blocks should be escaped like this: \`\`\`typescript\\ncode here\\n\`\`\`
- Regular backticks should be escaped as \`
- Newlines should be escaped as \\n
- Double quotes should be escaped as \\"

Make sure your response can be parsed by JSON.parse().`;var Fo=(r,e)=>{let o={},i=0,n=Number.POSITIVE_INFINITY,t=Number.NEGATIVE_INFINITY,f=new Map;for(let[u,w]of r.entries()){let s=w.trim(),g=f.get(s)||[];g.push(u),f.set(s,g)}for(let u of e){let w=u.substring(1).trim(),s=f.get(w);if(s?.length){let g=s.shift();if(g!==void 0)o[g]=u,i+=u.length+1,n=Math.min(n,g),t=Math.max(t,g)}}return{changedIndices:o,totalChangedLinesLength:i,minIndex:n,maxIndex:t}},$o=(r,e,o,i)=>{let n=Math.max(r-(i||0),0),t=Math.min(e+(i||0),o-1);return{start:n,end:t}},Go=(r,e,o,i)=>{let n=i,t=!0,f=!0,u=r,w=e;while(n>0&&(t||f)){if(t&&u>0){let s=o[u-1].length+1;if(s<=n)u--,n-=s;else t=!1}if(f&&w<o.length-1){let s=o[w+1].length+1;if(s<=n)w++,n-=s;else f=!1}if((u===0||!t)&&(w===o.length-1||!f))break;if(u===0)t=!1;if(w===o.length-1)f=!1}return{start:u,end:w}},Ro=(r,e,o,i)=>{let n=r>0?`...
`:"";for(let t=r;t<=e;t++)n+=`${o[t]||i[t]}
`;if(e<i.length-1)n+=`...
`;return n.trim()},Z=(r,e,o)=>{return r.reduce((i,n)=>{let t=n.fileContent.split(`
`),f=n.changedLines.split(`
`),{changedIndices:u,totalChangedLinesLength:w,minIndex:s,maxIndex:g}=Fo(t,f);if(w===0)return i;let l=e-w-n.fileName.length,{start:m,end:v}=$o(s,g,t.length,o);if(!o)({start:m,end:v}=Go(m,v,t,l));let L=Ro(m,v,u,t);return i.push({fileName:n.fileName,promptContent:L}),i},[])};var Cr=(r)=>r.fileName.length+r.promptContent.length;var k=(r,e)=>{let o=[],i=[],n=0;for(let t of r){let f=Cr(t);if(f>e)c.error(`Changes to file ${t.fileName} are larger than the max prompt length, consider using a model with a larger context window. Skipping file changes...`);else if(n+f>e)o.push(i),i=[t],n=f;else i.push(t),n+=f}if(i.length>0)o.push(i);return o};var W=p(()=>{d()});var re=(r,e)=>{let o=Z(r,e);return k(o,e)};var ee=p(()=>{W()});var oe=(r,e)=>{let o=Z(r,e,Vr);return k(o,e)};var ie=p(()=>{y();W()});var ne=(r,e)=>{let o=r.map((i)=>({fileName:i.fileName,promptContent:i.fileContent.split(`
`).map((n)=>`+${n}`).join(`
`)}));return k(o,e)};var te=p(()=>{W()});var q=(r,e,o,i="English")=>{let n=e-sr.length,t;switch(o){case"full":t=ne(r,n);break;case"changed":t=re(r,n);break;case"costOptimized":t=oe(r,n);break;default:throw new Error(`Review type ${o} is not supported. Please use one of the following: full, changed, costOptimized.`)}let f=sr.replace("{ProgrammingLanguage}",xr(r[0].fileName)).replace("{ReviewLanguage}",i);return t.map((w)=>{return f+JSON.stringify(w)})};var pr=p(()=>{Lr();ee();ie();te()});var ce,wr=(r)=>{return r.filter((o)=>{let i=ce.extname(o.fileName);return V.has(i)&&![...D].some((n)=>o.fileName.includes(n))&&o.changedLines.trim()!==""})};var fe=p(()=>{ce=require("path");y()});var ue=p(()=>{fe()});var se={};F(se,{review:()=>ko});var ko=async(r,e,o)=>{c.debug("Review started."),c.debug(`Model used: ${r.model}`),c.debug(`Ci enabled: ${r.ci??"ci is undefined"}`),c.debug(`Comment per file enabled: ${String(r.commentPerFile)}`),c.debug(`Review type chosen: ${r.reviewType}`),c.debug(`Organization chosen: ${r.org??"organization is undefined"}`),c.debug(`Remote Pull Request: ${r.remote??"remote pull request is undefined"}`);let{ci:i,commentPerFile:n,model:t,reviewType:f,org:u,provider:w,reviewLanguage:s}=r,g=wr(e);if(g.length===0){c.info("No file to review, finishing review now.");return}c.debug(`Files to review after filtering: ${g.map((co)=>co.fileName).toString()}`);let l=z(t),m=q(g,l,f,s);c.debug(`Prompts used:
 ${m.toString()}`);let{markdownReport:v,feedbacks:L}=await J(m,t,o,u,w);if(c.debug(`Markdown report:
${v}`),i==="github"){if(!n)await Y(v,R);if(n)await Hr(L,R)}if(i==="gitlab")await B(v,R),await Pr(v,R);if(i==="azdev")await kr(v,R);return v};var pe=p(()=>{Nr();ir();Mr();nr();Yr();cr();G();d();y();ur();pr();ue()});var we,No,Uo=(r)=>{return!No.includes(r)},Oo=(r)=>{let e=we.extname(r);return V.has(e)&&![...D].some((o)=>r.includes(o))},ge=(r,e)=>{return Uo(e)&&Oo(r)};var de=p(()=>{we=require("path");y();No=["removed","unchanged"]});class gr{client=new be.Octokit({auth:_r()});async fetchReviewFiles(r){let e=await this.client.paginate(this.client.rest.pulls.listFiles,{owner:r.owner,repo:r.repo,pull_number:r.prNumber});return await this.fetchPullRequestFiles(e)}async fetchPullRequestFiles(r){let e=[];for(let o of r){if(!ge(o.filename,o.status))continue;let i=await this.fetchPullRequestFile(o);e.push(i)}return e}async fetchPullRequestFile(r){let e=await this.fetchPullRequestFileContent(r.contents_url);return{fileName:r.filename,fileContent:e,changedLines:r.patch??""}}async fetchPullRequestFileContent(r){let e=await this.client.request(`GET ${r}`);if(To(e))return this.decodeBase64(e.data.content);throw new Error(`Unexpected response from Octokit. Response was ${JSON.stringify(e)}.`)}decodeBase64(r){return Buffer.from(r,"base64").toString("utf-8")}}var be,To=(r)=>typeof r==="object"&&r!==null&&("data"in r)&&typeof r.data==="object"&&r.data!==null&&("content"in r.data)&&typeof r.data.content==="string";var he=p(()=>{be=require("octokit");a();de()});var le=(r)=>{let[e,o,i,n,t]=r.split(/(\/|#)/),f=Number.parseInt(t);return{owner:e,repo:i,prNumber:f}};var ve={};F(ve,{getRemotePullRequestFiles:()=>Ho});var Ho=async(r)=>{let e=le(r),o=new gr;try{return await o.fetchReviewFiles(e)}catch(i){throw new Error(`Failed to get remote Pull Request files: ${JSON.stringify(i)}`)}};var me=p(()=>{he()});var Ee,Mo=(r)=>`"${r.replace(/(["$`\\])/g,"\\$1")}"`,Ko=(r,e)=>{let o=Mo(e);if(r==="github"){let{githubSha:i,baseSha:n}=$();return`git diff -U0 --diff-filter=AMRT ${n} ${i} ${o}`}if(r==="gitlab"){let{gitlabSha:i,mergeRequestBaseSha:n}=A();return`git diff -U0 --diff-filter=AMRT ${n} ${i} ${o}`}if(r==="azdev"){let{azdevSha:i,baseSha:n}=T();return`git diff -U0 --diff-filter=AMRT ${n} ${i} ${o}`}return`git diff -U0 --diff-filter=AMRT --cached ${o}`},Ae=async(r,e)=>{let o=Ko(r,e);return new Promise((i,n)=>{Ee.exec(o,(t,f,u)=>{if(t)n(new Error(`Failed to execute command. Error: ${t.message}`));else if(u)n(new Error(`Command execution error: ${u}`));else{let w=f.split(`
`).filter((s)=>s.startsWith("+")||s.startsWith("-")).filter((s)=>!(s.startsWith("---")||s.startsWith("+++"))).join(`
`);i(w)}})})};var ae=p(()=>{Ee=require("child_process");a();G()});var dr,_e,So=(r)=>{if(r==="github"){let{githubSha:e,baseSha:o}=$();return`git diff --name-only --diff-filter=AMRT ${o} ${e}`}if(r==="gitlab"){let{gitlabSha:e,mergeRequestBaseSha:o}=A();return`git diff --name-only --diff-filter=AMRT ${o} ${e}`}if(r==="azdev"){let{azdevSha:e,baseSha:o}=T();return`git diff --name-only --diff-filter=AMRT ${o} ${e}`}if(r===void 0)return"git diff --name-only --diff-filter=AMRT --cached";throw new Error("Invalid CI platform")},Po=()=>{return new Promise((r,e)=>{dr.exec("git rev-parse --show-toplevel",(o,i)=>{if(o)e(new Error(`Failed to find git root. Error: ${o.message}`));else r(i.trim())})})},Ie=async(r)=>{let e=await Po();c.debug("gitRoot",e);let o=So(r);return c.debug("commandString",o),new Promise((i,n)=>{dr.exec(o,{cwd:e},(t,f,u)=>{if(t)n(new Error(`Failed to execute command. Error: ${t.message}`));else if(u)n(new Error(`Command execution error: ${u}`));else{let w=f.split(`
`).filter((s)=>s.trim()!=="").map((s)=>_e.join(e,s.trim()));i(w)}})})};var ye=p(()=>{dr=require("child_process"),_e=require("path");a();G();d()});var Ge={};F(Ge,{getFilesWithChanges:()=>Yo});var Fe,$e,Yo=async(r)=>{try{let e=await Ie(r);if(c.debug("fileNames",e),e.length===0)c.warn("No files with changes found, you might need to stage your changes."),$e.exit(0);let o=await Promise.all(e.map(async(i)=>{let n=await Fe.readFile(i,"utf8"),t=await Ae(r,i);return c.debug("changedLines",t),{fileName:i,fileContent:n,changedLines:t}}));return c.debug("files",o),o}catch(e){throw new Error(`Failed to get files with changes: ${e.message}

${e.stack}`)}};var Re=p(()=>{Fe=require("fs/promises"),$e=require("process");d();ae();ye()});var ke={};F(ke,{getReviewFiles:()=>Bo});var Bo=async(r,e)=>{if(e!==void 0){let{getRemotePullRequestFiles:i}=await Promise.resolve().then(() => (me(),ve));return await i(e)}let{getFilesWithChanges:o}=await Promise.resolve().then(() => (Re(),Ge));return await o(r)};var Ne=`
Your role is to help testing a GPT application reviewing code changes. You receive a test case and you need to generate code in typescript corresponding to this test case, even if it follows bad practices or has security issues.
The test cases is formatted as a stringified JSON object with the following properties:
- name: the name of the test case
- description: the description of the test case

The input is the following:
{testCase}

Return the content of a valid typescript file that would pass the test case.
`,br=0.1,hr="#### Tests Powered by [Code Review GPT](https://github.com/mattzcarey/code-review-gpt)";var Ue,Oe,Te=async(r)=>{let e=new Ue.OpenAIEmbeddings;return await Oe.MemoryVectorStore.fromDocuments(r,e)};var He=p(()=>{Ue=require("@langchain/openai"),Oe=require("langchain/vectorstores/memory")});var Me,Ke,Se,Vo=async(r)=>{return await new Se.TextLoader(r).load()},Pe=async(r)=>{let e=Me.readdirSync(r),o=await Promise.all(e.map(async(i)=>{return Vo(Ke.default.join(r,i))}));return await Te(o.flat())};var Ye=p(()=>{Me=require("fs"),Ke=b(require("path")),Se=require("langchain/document_loaders/fs/text");He()});var Be,Q,Do=(r)=>typeof r==="object"&&r!==null&&("name"in r)&&typeof r.name==="string"&&("description"in r)&&typeof r.description==="string",zo=async(r)=>{try{let e=await Q.readFile(r,"utf8"),o=JSON.parse(e);if(!Do(o))throw new Error("File data is of unexpected format.");return o}catch(e){throw c.error(`Error loading test case: ${r}`),e}},Ve=async(r)=>{try{let e=(await Q.readdir(r)).filter((o)=>o.endsWith(".json"));return Promise.all(e.map(async(o)=>await zo(Be.default.join(r,o))))}catch(e){throw c.error(`Error loading test cases from: ${r}`),e}};var De=p(()=>{Be=b(require("path")),Q=require("fs/promises");d()});var ze,jo="sha256",je=(r)=>{return ze.default.createHash(jo).update(r).digest("hex")};var Je=p(()=>{ze=b(require("crypto"))});var X,Ze,Jo=async(r,e)=>{let o=Ne.replace("{testCase}",JSON.stringify(r));return(await e.callModel(o)).replace("```typescript","").replace("```","")},Zo=async(r,e,o)=>{if(r.snippet)return r;let i=je(r.description),n=Ze.default.join(e,`${i}.ts`);try{let t=X.readFileSync(n,"utf8");return{...r,snippet:{fileName:n,fileContent:t,changedLines:t}}}catch(t){c.info(`Snippet not found in cache: ${r.name}. Generating it...`);let f=await Jo(r,o);return X.writeFileSync(n,f,"utf8"),{...r,snippet:{fileName:n,fileContent:f,changedLines:f}}}},We=async(r,e,o)=>{return Promise.all(r.map((i)=>Zo(i,e,o)))};var qe=p(()=>{X=require("fs"),Ze=b(require("path"));d();Je()});var I,Qe,Wo=(r)=>{if(r>1-br)return"PASS";if(r>1-2*br)return"WARN";return"FAIL"},Xe=(r,e)=>{switch(r){case"PASS":return I.default.green(`✅ [PASS] - ${e}`);case"WARN":return I.default.yellow(`⚠️ [WARN] - ${e}`);case"FAIL":return I.default.red(`❌ [FAIL] - ${e}`)}},xe=(r,e,o,i)=>{let n=Wo(i),t=n!=="PASS",f=Xe(n,`Test case: ${r.name} - Similarity score: ${i}
`)+(t?qo(r,e,o):"");return{result:n,report:f}},qo=(r,e,o)=>`
 > Test case snippet: ${JSON.stringify(r.snippet)}

===============================================================================

 > Review:
${e}
===============================================================================

> Similar review:
${o}

`,Le=(r)=>{let e=Object.entries(r).reduce((i,[n,t])=>{return`${i+Xe(t,`Test case: ${n}`)}
`},I.default.blue(`
### Test results summary:
`)),o=Object.values(r).reduce((i,n)=>{return i[n]++,i},Object.fromEntries(Object.values(Qe).map((i)=>[i,0])));return`${e}
**SUMMARY: ${I.default.green(`✅ PASS: ${o.PASS}`)} - ${I.default.yellow(`⚠️ WARN: ${o.WARN}`)} - ${I.default.red(`❌ FAIL: ${o.FAIL}`)}**
`};var Ce=p(()=>{I=b(require("picocolors"));((i)=>{i.PASS="PASS";i.WARN="WARN";i.FAIL="FAIL"})(Qe||={})});var ro,Qo=async(r,e,o,i,n,t,f)=>{if(!e.snippet)throw new Error(`Test case ${e.name} does not have a snippet.`);c.info(ro.default.blue(`Running test case ${e.name}...`));let u=q([e.snippet],i,t,f),{markdownReport:w}=await J(u,o,r,void 0,"openai"),s=await n.similaritySearchWithScore(w,1);if(s.length===0)throw new Error(`No similar reviews found for test case ${e.name}.`);let[g,l]=s[0],{result:m,report:v}=xe(e,w,g.pageContent,l);return c.info(v),m},eo=async(r,e,o,i,n,t,f)=>{if(e.length===0)return"No test cases found.";c.info(`Running ${e.length} test cases...
`);let u={};for(let s of e)try{let g=await Qo(r,s,o,i,n,t,f);u[s.name]=g}catch(g){c.error(`Error running test case ${s.name}:`,g)}let w=Le(u);return c.info(w),w};var oo=p(()=>{ro=b(require("picocolors"));d();ur();pr();Ce()});var io={};F(io,{test:()=>Xo});var x,__dirname="/Users/enes/Desktop/Personal/code-review-gpt/src/test",Xo=async({ci:r,model:e,reviewType:o,reviewLanguage:i},n)=>{let t=z(e),f=await Ve(x.default.join(__dirname,"cases")),u=await We(f,x.default.join(__dirname,"cases/.cache"),new O({modelName:e,temperature:0,apiKey:n,organization:void 0,provider:"openai"})),w=await Pe(x.default.join(__dirname,"cases/snapshots")),s=await eo(n,u,e,t,w,o,i);if(r==="github")await Y(s,hr);if(r==="gitlab")await B(s,hr)};var no=p(()=>{x=b(require("path"));ir();nr();fr();cr();G();Ye();De();qe();oo()});var to=b(require("dotenv"));var wo=b(require("@inquirer/rawlist")),lr=b(require("dotenv")),vr=b(require("yargs")),mr=require("yargs/helpers");lr.default.config();var Er=async()=>{return vr.default(mr.hideBin(process.argv)).command("configure","Configure the tool").command("review","Review code changes").command("test","Run tests").demandCommand(1,"Please specify a command: configure, review, or test").option("ci",{description:"CI environment type",choices:["github","gitlab","azdev"],type:"string",coerce:(r)=>r||"github"}).option("setupTarget",{description:"Specifies for which platform ('github', 'gitlab' or 'azdev') the project should be configured for. Defaults to 'github'.",choices:["github","gitlab","azdev"],type:"string",default:"github"}).option("commentPerFile",{description:"Enables feedback to be made on a file-by-file basis. Only work when the script is running on GitHub.",type:"boolean",default:!1}).option("model",{description:"The model to use for generating the review.",type:"string",default:"gpt-4o-mini"}).option("reviewType",{description:"Type of review to perform. 'full' will review the entire file, 'changed' will review the changed lines only but provide the full file as context if possible. 'costOptimized' will review only the changed lines using the least tokens possible to keep api costs low. Defaults to 'changed'.",choices:["full","changed","costOptimized"],type:"string",default:"changed"}).option("reviewLanguage",{description:"Specifies the target natural language for translation",type:"string"}).option("remote",{description:"The identifier of a remote Pull Request to review",type:"string",coerce:(r)=>{return r||""}}).option("debug",{description:"Enables debug logging.",type:"boolean",default:!1}).option("org",{description:"Organization id to use for openAI",type:"string",default:void 0}).option("provider",{description:"Provider to use for AI",choices:["openai","azureai","bedrock"],type:"string",default:"openai"}).help().parse()};d();a();to.default.config();var xo=async()=>{let r=await Er(),e=ar();switch(c.settings.minLevel=r.debug?2:r.ci?4:3,c.debug(`Args: ${JSON.stringify(r)}`),r._[0]){case"configure":{let{configure:o}=await Promise.resolve().then(() => (Rr(),Gr));await o(r);break}case"review":{let{review:o}=await Promise.resolve().then(() => (pe(),se)),{getReviewFiles:i}=await Promise.resolve().then(() => ke),n=await i(r.ci,r.remote);await o(r,n,e);break}case"test":{let{test:o}=await Promise.resolve().then(() => (no(),io));await o(r,e);break}default:c.error("Unknown command"),process.exit(1)}};xo().catch((r)=>{let e=r instanceof Error?r.message:"An unknown error occurred",o=r instanceof Error?r.stack:"No stack trace available";if(c.error(`Error: ${e}`),o)c.debug(`Stack trace: ${o}`);process.exit(1)});
